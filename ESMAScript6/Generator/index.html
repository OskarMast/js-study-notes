<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Generator</title>
	</head>
	<body>
		<script>
			function* helloWorldGenerator(){
				yield 'hello';
				yield 'world';
				return 'ending';
			}
			const hw = helloWorldGenerator();	// 该函数并不会立即执行.返回的也不是函数运行的结果,而是一个指向内部状态的指针对象.
			console.log(hw.next());	// {value:'hello',done:false}
			console.log(hw.next());	// {value:'world',done:false}
			console.log(hw.next()); // {value:'ending',done:true}
			console.log(hw.next());	// {value:undefined,done:true}
			
			function* players(){
				yield 'kyrie';
				yield 'lebron';
				yield 'durant';
			}
			// 返回一个遍历器对象,代表Generaotr函数的内部指针.
			let player = players();
			console.log(Object.prototype.toString.call(player));	// Generator
			console.log(player.next());	// {value:'kyrie',done:false}
			console.log(player.next());	// {value:'lebron',done:false}
			console.log(player.next());	// {value:'durant',done:false}
			console.log(player.next());	// {value:undefined,done:true}
			
			
			// Generator函数可以不用yield表达式,这时就变成了一个单纯的暂缓执行函数.
			function* f(){
				console.log("函数执行了");
			}
			var g1 = f();
			setTimeout(()=>{
				console.log( g1.next() );
			},2000);
			
			
			// 将数组降为1维数组
			let arr = [1,[[2,3],4],[5,6]];
			function* flat(arr){
				for(let i = 0; i < arr.length; i++){
					var item = arr[i]
					if(typeof item === 'number'){
						yield item
					}else{
						yield* flat(item);
					}
				}
			}
			for(let item of flat(arr)){
				console.log(item);	// 1 2 3 4 5 6
			}
			
			// 将数组一维化
			let temp = []
			function flatArr(arr){
				for(let i = 0; i < arr.length; i++){
					var item = arr[i];
					if(typeof item !== "number"){
						flatArr(item);
					}else{
						temp.push(item);
					}
				}
				return temp;
			}
			let newFlatArr = flatArr(arr);
			console.log(newFlatArr);
			
			
			function* demo(){
				console.log("Hello" + (yield 123))
			}
			let Demo = demo();
			console.log( Demo.next() );	// 只会输出表达式后面的值
			
			let obj = {
				firstName:"kyrie",
				lastName:"irving"
			}
			console.log( obj[Symbol.iterator] );	// undefined
			// console.log([...obj])	
			console.log({...obj})
			
			
			// 任意一个对象的Symbol.Iterator方法,等于该对象的遍历器生成函数,调用该函数会返回该对象的一个遍历器对象.
			var myIterator = {}
			myIterator[Symbol.iterator] = function* (){
				yield 1;
				yield 2;
				yield 3;
			}
			console.log([...myIterator])	// [1,2,3]
			
			function* gen(){
				yield 1;
				yield 2;
				yield 3;
			}
			let g2 = gen();
			console.log(g2[Symbol.iterator]());	// 返回gen本身


			function* foo(){
				for(let i = 0; true; i++){
					let reset = yield i;
					if(reset){i = -1};
				}
			}
			let g3 = foo();
			console.log(g3.next());		// {value:0,done:false}
			console.log(g3.next());		// {value:1,done:false}
			console.log(g3.next(true))	// {value:0,done:false}
			
			
			function* bar(x){
				var y = 2 * (yield (x+1));
				var z = yield(y/3);
				return x + y + z;
			}
			var a = bar(5);
			console.log(a.next())	// {value:6,done:false}		// 每次调用next 输出的是yield后面的表达式
			console.log(a.next());	// {value:NaN,done:false}
			console.log(a.next());	// {value:NaN,done:true}
			
			// 给 next() 函数传递参数
			var b = bar(5);
			console.log(b.next());	// {value:6,done:false}
			console.log(b.next(12));	// {value:8,done:false}	 上一个yield表达式的值为12,可以求出y = 24
			console.log(b.next(13));	// {value:42,done:true}  5 + 24 + 13
			
			// tips: 由于next方法的参数表示上一个yield表达式的返回值,所以在第一次使用next方法时,传递参数是无效的.
			
		// 封装一个函数,函数里传入一个 generatorFunction,返回一个已经被调用过next方法的generatorObject对象.
		function wrapper(generatorFunction) {
		  return function () {
			let generatorObject = generatorFunction();
			generatorObject.next();
			return generatorObject;
		  };
		}
		const wrapped = wrapper(function* () {
		  console.log(`First input: ${yield}`);
		  return 'DONE';
		});

		wrapped().next('hello!')
		</script>
	</body>
</html>
