<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>let</title>
	</head>
	<body>
		<script>
			//一.  有块级作用域
			{
				let a = 10;
				var b = 1;
			}
			// console.log(a,b);	// a is not defined
			
			
			// 计数器i只在for循环体内有效,在循环体外引用就会报错.
			for(let i = 0; i < 10; i++){
				// console.log(i);
			}
			// console.log(i);		// i is not defined
			
			// ajax封装, i是var声明的在全局范围内有效.全局只有一个变量i.
			var a = [];
			for (var i = 0; i < 10; i++) {
			  a[i] = function () {
				console.log(i);
			  };
			}
			a[6](); // 10	为什么循环外的i输出为10？
			console.log(a);

			/*
			变量i是let声明的,当前的i只在本轮循环有效，每一次循环的i都是一个新的变量。
			*/ 
			var b = [];
			for(let i = 0; i < 10; i++){
				b[i] = function(){
					console.log(i);
				}
			}
			b[6]();	// 6
			
			/*
			for循环设置循环变量的那部分是一个父作用域,而循环体内部是一个单独的子作用域。
			*/
			for(var j = 0; j < 3; j++){
				var j = "hello";
				console.log(j);
			}
			for(let j = 0; j < 3; j++){
				let j = "hello";
				console.log(j);	// 输出3次hello
			}
			
			/*
			二   没有变量提升(暂时性死区),只要块级作用域内存在let,它所声明的变量就"绑定"这个区域，不再受外部的影响
			
			ES6 明确规定，如果区块中存在let和const命令,这个区块对这些命令声明的变量,从一开始就形成了封闭作用域。凡是在声明之前
			就使用这些变量，就会报错！
			*/ 
		   var tmp = 123;
		   if(true){
			   tmp = "abc";
			   // let tmp;	// is not defined
		   }

		   
		   /*
		   三 : let不允许在相同的作用域内重复声明同一个变量。因此不能再函数内部重新声明函数
		   */
		   function fun(){
			   let a = 1;
			   // var a = 2;	// a has already been declared
		   }
			
			function fun2(){
				let a = 1;
				//let a = 2;	// 报错
			}
			
			
			/*
			四: 块级作用域 ES5 只有全局作用域和函数作用域。
			1. 内层变量可能会覆盖外层变量
			2. for循环变量泄露为全局变量
			*/
		   var temp = new Date();
		   function f(){
			   console.log(temp);
			   if(false){
				   var temp = "hello world";
			   }
		   }
		   f();	// undefined   判断语句里的temp覆盖了外层的temp变量
		   
		   
		   function f1(){
			   console.log("i am outside")
		   }
		   (function(){
			   if(false){
				 function f1(){console.log("i am inside")}
			   }
			   // f1();	// f1 is not defined
		   })()
		   
		   // 下面的代码在ES5 的环境中,if内的函数f1会被提升到函数头部,实际运行的代码如下
		   /*
		   function f1(){console.log("i am outside")}
		   (function(){
			   function f1(){console.log(i am inside)}
			   if(false){}
			   f1();
		   })()
		   */
		  // 在ES6 允许在块级作用域内声明函数,函数声明类似于var,会提升到全局作用域或函数作用域的头部
		  // 也会提升到所在的块级作用域的头部
		</script>
	</body>
</html>
