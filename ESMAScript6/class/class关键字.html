<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Class</title>
</head>
<body>
<script>
	// JavaScript中,生成实例对象的传统方法是通过构造函数。
	function Point(x,y){
		this.x = x;
		this.y = y;
	}
	Point.prototype.toString = function(){
		return `${this.x + this.y}`;
	}
	let p1 = new Point(1,3);
	console.log(p1.toString());

	/*上面的代码 使用ES6改写*/
	class Point1{
		// 构造方法
		constructor(x,y){
			this.x = x;
			this.y = y;
		}
		toString(){
			return `${this.x + this.y}`;
		}
	}
	let p2 = new Point1(1,3);
	console.log(p2.toString());
	console.log(p2.constructor);
	console.log(Point1.prototype.constructor === Point1);

    class Player{
        constructor(firstName,lastName){
            this.firstName = firstName;
            this.lastName = lastName;
        }
        say(){
            console.log(`my name is ${this.firstName}-${this.lastName}`);
        }
        greet(){
            console.log('hello');
        }
    }
    let player = new Player('kyrie','irving');
    player.greet();
    player.say();

    console.log(Object.keys(Player.prototype));     // []
    console.log(Object.getOwnPropertyNames(Player.prototype)); // ["constructor", "say", "greet"]
/*
    function Player(firstName,lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    Player.prototype.say = function(){
        console.log(`my name is ${this.firstName}-${this.lastName}`);
    }
    Player.prototype.greet = function(){
        console.log('hello');
    }
    let player = new Player('kyrie','irving');
    console.log(Object.keys(Player.prototype)); // ['say','greet']
    console.log(Object.getOwnPropertyNames(Player.prototype));  // ["constructor", "say", "greet"]
    for(let key in Player.prototype){
        console.log(key);
    }
 */

    class Pointer {
        constructor(x,y){
            this.x = x;
            this.y = y;
        }
        toString(){
            console.log(this.x + this.y);
        }
    }
    const p = new Pointer(1,2);
    p.toString();   // 3
    console.log(p.hasOwnProperty('x')); // true
    console.log(p.hasOwnProperty('y')); // true
    console.log(p.hasOwnProperty('toString'));  // false
    console.log(p.__proto__.hasOwnProperty('toString'));    // true


    class Logger{
        printName(name='there'){
            this.print(`hello ${name}`);
        }
        print(text){
            console.log(text);
        }
    }
    let logger = new Logger();
    logger.printName();


    class Foo {
        static classMethod(){
            console.log('Hello');
        }
    }
    let foo = new Foo();
    // foo.classMethod();  //  foo.classMethod is not a function
    Foo.classMethod()   // Hello



    class Bar {
        static bar(){
            this.baz()  // 静态方法的this指向的是Bar构造方法
        }
        static baz(){
            console.log('静态方法baz');
        }
        baz(){
            console.log('原型上的方法baz')
        }
    }
    Bar.baz();   // 静态方法baz
    let bar = new Bar();
    bar.baz();  // 原型上的方法baz

    class ChildBar extends Bar{
    }

    ChildBar.bar(); // 静态方法baz


    class IncresingCounter {
        constructor(){
            this._count = 0;
        }
        increment(){
            this._count++;
            console.log(this._count);
        }
    }
    let increase = new IncresingCounter();
    increase.increment();   // 1

    class Father  {
        bar = 'hello';
        baz = 'world';
    }
    let f = new Father();
    console.log(f.bar); // hello
    console.log(f.baz); // world

</script>
</body>
</html>