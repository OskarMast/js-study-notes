<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Class的继承</title>
</head>
<body>
<script>
    class Point{
        constructor(x,y){
            this.x = x;
            this.y = y;
        }
        toString(){
            return `${this.x + this.y}`;
        }
    }
    /*
    class ColorPoint extends Point{
        constructor(x,y,color){
            super(x,y); // 调用父类的constructor(x,y)
            this.color = color;
        }
        toString(){
            console.log(this.color + " " + super.toString());
        }
    }
    let cp = new ColorPoint(1,2,'red');
    cp.toString();  // red 3
    */

    class ColorPoint extends Point{
        constructor(x,y,color){
            super(x,y);
            this.color = color;
        }
        toString(){
            console.log( this.color + super.toString() );
        }
    }
    let cp = new ColorPoint(1,2,'green');
    cp.toString();

    console.log(cp instanceof ColorPoint);  // true
    console.log(cp instanceof Point);       // true


    class Player {
        sayName(){
            console.log(this.name);
        }
    }

    class ChildPlayer extends Player{
        constructor(...args){
            super(...args);
            this.name = 'kyrie';
        }
        sayName(){
            super.sayName();
        }
    }
    let childplayer = new ChildPlayer();
    childplayer.sayName();  // kyrie


    class A{
        static p(){
            console.log('父类的静态方法');
        }
        p(){
            console.log('父类的方法');
        }
    }
    class B extends A {
        constructor(){
            super()
        }
        say(){
            super.p()
        }
        static say(){
            super.p()
        }
    }
    let b = new B();
    B.say();    // 父类的静态方法
    b.say();    // 父类


    class Foo{
        constructor(){
            this.name = 'kyrie'
        }
        sayName(){
            console.log(this.name);
        }
    }
    Foo.prototype.name = 'irving'
    class Bar extends Foo{
        say(){
            console.log( super.name );  // undefined
            super.sayName()
        }
    }
    let bar = new Bar();
    bar.say()


    class Father{
        constructor(){
            this.x = 1
        }
        print(){
            console.log(this.x);
        }
    }
    let father = new Father();
    father.print(); // 1

    class Son extends Father{
        constructor(){
            super();
            this.x = 2;
            super.x = 3;    // super指的就是子类的this,所以this.x = 3 super指向父类的原型,而原型上没有x，所以为undefined
            console.log(super.x);   // undefined
            console.log(this.x);    // 3
        }
        m(){
            super.print();
            /* super.print()虽然调用的是Father.prototype.print(),但是Father.prototype.print()内部的this
            *   指向的是子类Son的实例，所以输出的是2. 实际上执行的是 super.print.call(this)
            * */
        }
    }
    let son = new Son();
    son.m();    // 2


    class Parent{
        constructor(){
            this.x = 2;
        }
        static myMethod(msg){
            console.log('static',msg);
        }
        myMethod(msg){
            console.log('instance',msg);
        }
        static print(){
            console.log(this.x);
        }
    }

    class Child extends Parent{
        constructor(){
            super();
            this.x = 3;
        }
        static myMethod(msg){
        // 静态方法中的super指向父类
            super.myMethod(msg)
            // 静态方法里 super.print()指向父类的静态方法,这个方法里面的this指向的是Child,而不是Child的实例
            super.print();  // 4
        }
        myMethod(msg){
        // 普通方法中的super指向父类的原型
            super.myMethod(msg);
        }
    }
    Child.x = 4;
    Child.myMethod(1);  // static 1
    let child = new Child();
    child.myMethod(1);  // instance 1










































































</script>
</body>
</html>