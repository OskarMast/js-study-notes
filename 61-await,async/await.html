<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>await</title>
	</head>
	<body>
		<script>
			// 正常情况下,await命令后面是一个promise对象,返回该对象的结果.如果不是promise对象,就直接返回对应的值.
			async function f1(){
				return await `f1 123`;
				// return 123
			}
			async function f2(){
				return `f2 123`
			}
			async function f3(){
				let a = await `f3 123`
				return a;
			}
			f1().then(res => {
				console.log(res);
			})
			f2().then(res => {
				console.log(res);
			})
			f3().then(res => {
				console.log(res);
			})
			
			
			// await命令后面是一个thenable对象(即定义then方法的对象),那么await会将其等同于Promise对象.
			class Sleep{
				constructor(timeout){
					this.timeout = timeout;
				}
				then(resolve,reject){
					const startTime = Date.now();
					setTimeout(() => {
						resolve(Date.now() - startTime)
					},this.timeout);
				}
			}
			(async function(){
				const sleepTime = await new Sleep(1000);
				console.log(sleepTime);
			})()
			
			
			// 任何一个await语句后面的promise对象变为reject状态,那么整个async函数都会中断执行.
			async function foo(){
				await Promise.reject('出错了');
				await Promise.resolved('hello world');
			}
			foo().then(data => {
				console.log(data);
			})
			.catch(err => {
				console.log(err);
			})
			
			
			// 有时希望即使前一个异步操作失败,也不要中断后面的异步操作,这时可以将第一个await放在try...catch结构里.
			async function baz(){
				try{
					await Promise.reject('出错了');
				}catch(err){
					console.log(err);
				}
				return await Promise.resolve('hello world!');
			}
			baz().then(v => {
				console.log(v);
			})
			
			
			// 另一种方法是在await后面的promise对象再跟一个catch方法,处理前面可能出现的错误.
			async function bar(){
				await Promise.reject('err').catch(e => {
					console.log(e);
				})
				return await Promise.resolve('hello world');
			}
			bar().then(data =>{
				console.log(data);
			}).catch(err => {
				console.log(err);
			})
			
			
			// 如果await后面的异步操作出错,那么等同于async函数返回的promise对象被reject.
			async function m1(){
				await new Promise((resolve,reject) => {
					throw new Error('出错了');
				});
				console.log('nihao');
			}
			// m1();	// 报错,不会输出 nihao
			m1().then(v => {
				console.log(v);
			})
			.catch(err => {
				console.log(err);
			})
			
			
			function timeout(value,ms){
				return new Promise((resolve,reject)=>{
					setTimeout(resolve,ms,value);
				})
			}
			async function f4(){
				let name = await timeout('kyrie',1000);
				console.log(name);
			}
			f4();
			
			async function f5(){
				return await timeout('lebron',2000);
			}
			f5().then(data => {
				console.log(data);
			})
			
			
			/*
			tips:
			1. await命令后面的promise对象，运行结果可能是rejected，最好把await命令放在try...catch代码块中
			*/
		   async function myFunction(){
			   try{
				   await somethingThatReturnsAPromise();
			   }catch(err){
				   console.log(err);
			   }
		   }
		   
		   // 2. 如果多个await命令后面的异步操作不存在继发关系,最好让它们同时出发.
		   function p1(){
			   return new Promise((resolve,reject) => {
				   setTimeout(resolve,2000,'你好');
			   })
		   }
		   function p2(){
			   return new Promise((resolve,reject)=>{
				   setTimeout(resolve,2000,'世界');
			   })
		   }
		   
		   async function printWord(){
			   let start = new Date();
			   let a = await p1();
			   let b = await p2();
			   console.log(a,b);
			   console.log(new Date() - start);
		   }
		   printWord();	// 4000ms后再输出 你好 世界
		   
		   
		   // 下面的函数执行输出大约2000ms 后再输出 你好世界
		   async function print1(){
			   let start = new Date();
			   let [a,b] = await Promise.all([p1(),p2()]);
			   console.log(a,b);
			   console.log(new Date() - start);
		   }
		   print1()
		   
		   async function print2(){
			   let start = new Date();
			   let aPromise = p1();
			   let bPromise = p2();
			   let a = await aPromise;
			   let b = await bPromise;
			   console.log(new Date() - start);
			   console.log(a,b);
		   }
		   print2()
		   
		</script>
	</body>
</html>
