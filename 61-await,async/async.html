<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>await/async</title>
	</head>
	<body>
		<script>
			// async 函数返回一个promise,
			async function sayHello(){
				return 'hello';
			}
			console.log(sayHello());	// Promise {<resolved>:'hello'}
			sayHello().then(res=>{
				console.log(res)	// hello
			});
			
			
			// 指定多少ms后输出一个值.
			function timeout(ms){
				return new Promise((resolve,reject)=>{
					setTimeout(resolve,ms);
				})
			}
			async function asyncPrint(value,ms){
				await timeout(ms);
				console.log(value);
			}
			asyncPrint('hello',400);	// 先执行timeout函数,在执行console.log
			
			// async函数返回的是一个promise对象,可以作为await的参数
			/*async function print(ms){
				await new Promise((resolve,reject) => {
					setTimeout(resolve,ms);
				});
			}*/
			
			async function print(ms){
				return new Promise((resolve,reject) => {
					setTimeout(resolve,ms);
				})
			}
			
			async function asyncPrintValue(value,ms){
				await print(ms);
				console.log(value);
			}
			console.log(print(400));	// Promise
			asyncPrintValue('hello world',800);
			
			
			// async返回一个promise对象,return语句的返回值,会成为then方法回调函数的参数.
			async function f(){
				return 'hello china';
			}
			f().then(data=>{
				console.log(data);
			})
			
			// async函数内部的错误,抛出的错误会被catch方法回调函数接收到.
			async function f1(){
				throw new Error('出错了');
			}
			f1().then(data=>{
				console.log(data);
			})
			.catch(err=>{
				console.log(err);
			})
			
			// async 函数返回的promise对象,必须要等到内部所有await命令后面的promise对象执行完,才会发生状态改变.
			/*
				在下面的案例中，你好是同时输出的 await后面的promise语句执行完后再执行
				then方法的回调函数
			*/
			async function foo(){
				let response = await new Promise((resolve,reject)=>{
					setTimeout(resolve,2000,'你');
				})
				let str = await new Promise((resolve,reject)=>{
					setTimeout(resolve,100,'好');
				})
				console.log(response,str);
				return response + str;
			}
			foo().then(data=>{
				console.log(data);
			})
		</script>
	</body>
</html>
