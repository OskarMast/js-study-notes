<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>useMemo</title>
</head>
<body>
<div id="root"></div>
<script src="./node_modules/babel-standalone/babel.js"></script>
<script src="./node_modules/react/umd/react.development.js"></script>
<script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
<script type="text/babel">
    const useState = window.React.useState;
    const useMemo = window.React.useMemo;
    const memo = window.React.memo;
    const useCallback = window.React.useCallback;
    const Counter = memo(function Counter({count}){
        console.log("counter render");
        return (
            <div>
                <p>子组件Counter: {count}</p>
            </div>
        )
    })

    function App(){
        const [count,setCount] = useState(0);
        const [time,setTime] = useState(new Date().getMilliseconds());
        const handleAdd = () => {
            setCount(count+1);
        }
        const handleChangeTime = () => {
            setTime(new Date().getMilliseconds());
        }
        function doubleCount(count){
            console.log("doubleCount - function - 执行了");
            return count * 2;
        }
            /* 这种写法 每次count 和 time 变化时 都会 执行doubleCount 函数 */
        // const dbCount = doubleCount(count);

        /* 使用useMemo 可以阻止重复执行逻辑函数 第一个参数为一个回调函数,第二个参数参数有三种情况:
        *  1. 什么都不传的话，则跟不使用useMemo效果是一样的，每次在不修改count的情况下也会执行。
        *  2. 传递一个空数组,则只会在初始渲染时执行一次,即使count改变时也不会执行逻辑函数
        *  3. 传递一个 数组项,该项每次修改时会调用
        *  */

/*        const dbCount = useMemo(() => {
            return doubleCount(count);
        },[count])*/

        /*
        *  数组项是一个 boolean 值, count为1 和 2 的时候都是false,此时数组项没有修改, dbCount不会执行
        *  count为3时 从 false->true, dbCount为6 count为4时,数组项从 true -> false, dbCount为8
        *  此后 count自增数组项一直为false, dbCount不会执行
        * */
        let dbCount = useMemo(() => {
            return doubleCount(count);
        },[count === 3])

        /*
        *   结合 React.memo() 给Counter 传递一个 函数，当count为 1 和 2的时候, dbcount不会修改, Counter也不会
        * 重新渲染,但是传递给Counter 的函数每次都是一个新的句柄会导致Counter重新渲染
        *
        * 1. 使用useMemo 只在渲染的时候执行一次,这样子组件可以避免重复渲染
        * */
/*        const handleClick = () => {
            console.log("click");
        }*/
        const handleClick = useMemo(() => {
            return () => {
                console.log("click")
            }
        },[]);
        const handleCallback = useCallback(() => {
            console.log("callback");
        },[])
        return (
            <div>
                <p>Click {count} times</p>
                <p>double-count: {dbCount}</p>
                <p>time:{time}</p>
                <Counter count={dbCount} handleClick={handleClick} handleCallback={handleCallback}/>
                <input
                    type="button"
                    defaultValue="click"
                    onClick={handleAdd}
                />
                <input type="button"
                    defaultValue="changeTime"
                    onClick={handleChangeTime}
                />
            </div>
        )
    }

    ReactDOM.render(
        <App/>,
        document.getElementById("root")
    )
</script>
</body>
</html>